## 运行时常量与编译时常量重新理解

Q：`constexpr`和`const`有什么区别，我一直以为只有`constexpr`定义的才是编译时常量

A：在 C++11 引入 `constexpr` 之前，`const` 被迫身兼数职；而在 C++11 之后，`constexpr` 才是真正的“编译时常量”，而 `const` 回归了它“只读”的本意。

`const int size = 5;` 能用作编译时常量，是因为 C++ 为了兼容性和历史原因保留了一个**特例**。



**`const` (Read-only)**:

- **语义**：承诺**“我不修改这个变量”**。
- **本质**：它主要是一个**访问控制**修饰符。它告诉编译器：“帮我盯着点，别让我或者别人改写这块内存”。
- **时间点**：它既可以是编译时确定的，也可以是运行时才确定的。



**`constexpr` (Constant Expression)**:

- **语义**：承诺**“我在编译时就能计算出结果”**。
- **本质**：它主要是一个**优化和计算**修饰符。它告诉编译器：“赶紧把这个值算出来，直接硬编码到程序里，不要等到运行时候再去算”。
- **时间点**：强制在编译时确定（用于变量时）。



### :thinking: 为什么 `const` 也能做编译时常量？（历史遗留的特例）

在 C++98 时代，没有 `constexpr`。如果我们想定义一个数组大小 `int arr[N]`，必须需要一个常量。 标准规定：**如果一个 `const` 修饰的 `整数类型 (integral type)` 被 `常量表达式` 初始化，那么它本身也就成了编译时常量。**



最大区别

**`const` 修饰函数**（仅限成员函数）： 表示该函数不会修改类的成员变量。

```c++
class Test {
    int getVal() const { return val_; } // 我承诺不改 this->val_
};
```

**`constexpr` 修饰函数**： 表示该函数的**代码逻辑足够简单**，如果传入的参数是常量，由于函数体逻辑已知，编译器可以在**编译阶段直接把函数执行一遍，拿到结果**！

```c++
constexpr int square(int n) {
    return n * n;
}

int main() {
    // 场景 A：参数是编译时常量
    // 编译器在编译时直接计算 square(5)，把 25 填入 arr 的大小
    int arr[square(5)];  // ✅ 合法！相当于 int arr[25]

    // 场景 B：参数是变量
    // 编译器无法在编译时计算，它会退化成一个普通的函数调用
    int x = 10;
    int y = square(x);   // ✅ 合法，但在运行时计算
}
```

*注意：`const` 函数永远做不到这一点，它只是说“我不改数据”，不代表“我能在编译时运行”。*



### 总结对照

| **特性**         | `const`                                         | `constexpr`                                        |
| ---------------- | ----------------------------------------------- | -------------------------------------------------- |
| **核心含义**     | **只读** (Read-only)                            | **常量表达式** (Compile-time const)                |
| **用于整数变量** | ==如果初始值是常量，则提升为编译时常量 (特例)== | **必须**是编译时常量                               |
| **用于浮点变量** | 运行时只读变量 (C++98)                          | 编译时常量                                         |
| **用于指针**     | 指针本身不可变 或 指向的内容不可变              | 指针本身必须是编译时常量（地址固定）               |
| **用于函数**     | 仅成员函数：表示不修改对象状态                  | 表示函数逻辑可在编译期执行                         |
| **内存分配**     | 可能分配内存，也可能被优化掉                    | 变量通常不分配内存（直接替换为立即数），除非取地址 |







